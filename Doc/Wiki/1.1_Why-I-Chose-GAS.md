# **0\. Gameplay Ability System(GAS) 도입 배경**

이 문서는 우리 프로젝트가 언리얼 엔진의 Gameplay Ability System(GAS)을 핵심 아키텍처로 채택하게 된 기술적 배경을 설명합니다. 복잡한 게임 시스템을 직접 구현하며 얻은 경험을 바탕으로, 왜 GAS가 현시점에서 우리에게 최적의 선택지였는지 그 이유를 공유하고자 합니다.

### **1\. 첫 번째 장벽: 직접 구현의 복잡성과 마주하다**

GAS를 도입하기 전, 저희는 두 번의 프로젝트를 통해 복잡한 게임 시스템을 밑바닥부터 구축하는 경험을 했습니다.

#### **도전 1: 싱글플레이어 게임의 상태 관리**

첫 프로젝트는 **싱글플레이 소울라이크 게임**이었습니다. 캐릭터의 모든 상태(공격, 이동, 회피, 가드 등)와 스킬 시스템, 그리고 수많은 버프와 디버프를 직접 관리하는 것은 생각보다 훨씬 어려운 일이었습니다. 다음과 같은 요구사항이 얽히기 시작하자 코드는 걷잡을 수 없이 복잡해졌습니다.

* **상태 간의 상호작용**: 공격 중에는 이동은 불가능하지만, 캐릭터 회전은 가능해야 한다.
* **예외 처리**: 특정 스킬을 사용하는 도중 피격당하면, 해당 스킬은 즉시 취소되어야 한다.
* **우선순위**: 여러 효과가 중첩되었을 때, 어떤 디버프가 다른 버프를 무시하게 할 것인가?

새로운 기능을 추가할 때마다 기존 코드의 대규모 수정이 불가피했고, 이는 예측 불가능한 버그의 원인이 되었습니다.

#### **도전 2: 멀티플레이어 환경의 동기화 문제**

두 번째 **멀티플레이 어드벤처 게임** 프로젝트는 문제를 완전히 다른 차원으로 끌어올렸습니다. 싱글플레이 환경에서 잘 작동하던 로직은 네트워크 환경에서 무용지물이었습니다.

* **상태 동기화(Synchronization)**: 클라이언트와 서버가 바라보는 캐릭터의 상태가 미세하게 어긋나기 시작했습니다.
* **클라이언트 예측(Prediction)**: 네트워크 지연(Latency)을 감추기 위한 예측 로직과, 서버의 판정을 받아들이는 보정 로직 구현이 필요했습니다.
* **데이터 복제(Replication)**: 모든 데이터를 항상 동기화하는 것은 비효율적이므로, '어떤 데이터를', '언제', '누구에게' 전송할지 결정하는 최적화가 필수적이었습니다.
* **서버 권한(Server Authority)**: 치트 방지를 위해 모든 중요 판정은 서버가 독점해야 했고, 이는 코드 구조를 더욱 복잡하게 만들었습니다.

이러한 문제들을 해결하기 위한 보일러플레이트 코드를 작성하며, 저희는 직접 만든 시스템의 구조적 한계를 절감했습니다.

### **2\. GAS, 검증된 해결책을 만나다**

GAS는 저희가 겪었던 문제들에 대해 Epic Games가 수년간 고민하고 다듬어온 결과물이었습니다. 특히 세 가지 측면에서 깊은 인상을 받았습니다.

첫째, GameplayTag를 이용한 계층적 상태 관리  
더 이상 bCanMove, bCanAttack 같은 수많은 bool 변수로 상태를 관리할 필요가 없었습니다. 계층적 태그 시스템은 복잡한 상태를 직관적이고 유연하게 통제할 수 있게 해줍니다.  
예를 들어, 플레이어의 이동을 막는 여러 상태 이상('속박', '빙결')이 있다고 가정해 봅시다. '속박'은 State.Debuff.Movement.Snare로, '빙결'은 State.Debuff.Movement.Freeze 태그로 관리할 수 있습니다. 이때 캐릭터의 이동 로직은 **상위 태그인 State.Debuff.Movement의 존재 여부만 검사**하면 됩니다. '속박'에 걸리든 '빙결'에 걸리든, 이동을 막는다는 핵심 로직은 하나로 통일됩니다.

반면, UI에서는 각 하위 태그를 구체적으로 확인하여 "속박됨\!", "빙결됨\!"과 같이 세분화된 상태 정보를 플레이어에게 보여줄 수 있습니다. 이처럼 GAS의 태그 시스템은 로직의 단순함과 표현의 구체성을 동시에 만족시키는 강력한 도구입니다.
```cpp
// 예시: 이동 불가 상태를 나타내는 계층적 GameplayTag  
State.Debuff.Movement.Snare   // '속박' 상태  
State.Debuff.Movement.Freeze  // '빙결' 상태

// 캐릭터 이동 로직은 상위 태그만으로 모든 이동 불가 상태를 확인  
if (Actor.HasTag("State.Debuff.Movement"))   
{  
// 이동 로직 비활성화  
}

// UI는 구체적인 하위 태그를 확인하여 상태 아이콘이나 텍스트를 표시  
if (Actor.HasTag("State.Debuff.Movement.Snare"))  
{  
// '속박' 아이콘 표시  
}
```

둘째, 멀티플레이를 위한 내장 기능  
GAS는 태생부터 멀티플레이를 염두에 두고 설계되었습니다.

* 어빌리티의 **서버 실행**과 **클라이언트 예측**이 프레임워크 수준에서 지원됩니다.
* AttributeSet의 속성 값이 변경되면 자동으로 클라이언트에 복제됩니다.
* GameplayEffect의 적용과 해제가 안정적으로 동기화됩니다.

셋째, 시스템 간의 느슨한 결합(Loose Coupling)  
직접 구현 시 가장 어려웠던 의존성 문제를 GAS는 우아하게 해결했습니다.

* **입력 시스템**은 특정 GameplayTag를 활성화할 뿐, 어떤 어빌리티가 실행될지는 신경 쓰지 않습니다.
* **HUD**는 AttributeSet의 값 변경 델리게이트에 바인딩하여, 값이 바뀔 때만 반응형으로 UI를 업데이트합니다.
* **어빌리티**는 다른 캐릭터의 속성을 직접 수정하는 대신, GameplayEffect라는 데이터 객체를 통해 간접적으로 영향을 미칩니다.

### **3\. 바퀴를 직접 만들어 본 자의 관점: GAS에서 배운 것들**

오늘날 많은 언리얼 엔진 게임들이 GAS를 사용하지 않고 독자적인 시스템을 성공적으로 구축합니다. GAS가 유일한 정답은 아니라는 의미입니다. 하지만 저희에게 GAS는 특별한 의미를 가졌습니다. **이미 우리만의 '바퀴'를 고통스럽게 만들어 본 경험이 있었기 때문**입니다.

그 경험 덕분에 Epic Games가 제시하는 '검증된 바퀴'를 보며 단순히 기능을 배우는 것을 넘어, 그 안에 담긴 설계 철학을 깊이 이해할 수 있었습니다.

* 직접 구현 시 가장 골치 아팠던 '상태'와 '행위'의 분리 문제를, GAS가 **Ability**와 **Effect**로 명확히 나눈 것을 보고 그 설계의 깊이를 체감했습니다.
* 쿨다운과 코스트처럼 반복되는 로직을 별도의 \*\*GameplayEffect\*\*로 처리하는 것을 보며, 재사용성과 데이터 기반 설계를 어떻게 구현하는지에 대한 통찰을 얻었습니다.
* 직접 구현했다면 수많은 예외 처리가 필요했을 \*\*예측(Prediction)\*\*과 **롤백(Rollback)** 로직이 프레임워크에 내장된 것을 보며, 잘 설계된 시스템의 안정성이 어디서 비롯되는지 배울 수 있었습니다.

이 과정은 단순히 남의 코드를 분석하는 것을 넘어, 저희가 겪었던 문제들에 대한 훨씬 성숙한 해결책을 학습하는 기회였습니다.

### **4\. 결론: 더 나은 바퀴를 만들기 위한 선택**

결론적으로, GAS 도입은 단순히 '검증된 바퀴를 가져다 쓰는' 편리함의 문제가 아니었습니다. 직접 바퀴를 만들어 본 경험이 있었기에, 검증된 바퀴의 구조를 깊이 이해하고 우리 프로젝트에 필요한 방향으로 개선할 수 있는 **아키텍처적 통찰력**을 얻는 과정이었습니다.

GAS라는 견고한 기반 위에서, 우리는 밑바닥 시스템을 만드는 데 드는 비용을 줄이는 동시에, 우리가 왜 이런 구조를 선택했는지 명확히 이해하고 더 나은 시스템을 구축할 수 있었습니다.