# 프로젝트 회고 (첫 GAS 적용)

## 1. 배경

본 프로젝트는 첫 GAS(Gameplay Ability System) 적용 사례였습니다. C/Q/E 스킬 12개를 빠르게 확장 가능한 형태로 구현하는 것이 핵심 목표였습니다.

## 2. 주요 설계 원칙 및 교훈 (Key Design Principles & Lessons Learned)

이 프로젝트는 단순히 기능을 구현하는 것을 넘어, 확장 가능하고 유지보수하기 좋은 시스템을 만드는 것에 대한 깊은 고민의 과정이었습니다. 그 과정에서 다음과 같은 핵심적인 설계 원칙과 교훈을 얻을 수 있었습니다.

*   **컴포넌트 기반 설계의 힘**: 상점(`UShopComponent`), 재화(`UCreditComponent`), 섬광(`UFlashComponent`) 등 게임의 주요 기능들을 독립적인 `ActorComponent`로 분리한 것은 최고의 선택 중 하나였습니다. 각 컴포넌트가 자신의 역할과 데이터만 책임지게 함으로써, 시스템 간의 의존성을 크게 낮추고 특정 기능을 수정하거나 테스트할 때 다른 부분에 미치는 영향을 최소화할 수 있었습니다.

*   **데이터와 로직의 명확한 분리**: **\'성능과 안정성은 C++로, 유연성과 편의성은 블루프린트로\'** 라는 하이브리드 아키텍처 원칙을 모든 시스템에 일관되게 적용했습니다. 스킬의 상태 머신, 네트워크 로직 등은 C++ 기반 클래스에 구현하고, 실제 피해량, 이펙트, 사운드와 같은 데이터는 모두 블루프린트에서 설정하도록 분리했습니다. 이는 기획자나 아티스트가 코드 수정 없이 스킬의 밸런스와 외형을 자유롭게 수정할 수 있는 효율적인 개발 파이프라인을 구축하는 기반이 되었습니다.

*   **GAS는 단순한 스킬 시스템이 아니다**: 처음에는 GAS를 단순히 스킬을 사용하는 도구로만 생각했지만, 프로젝트를 진행하며 GAS가 제공하는 `GameplayTag`, `GameplayEvent`, `GameplayTask`가 얼마나 강력한 시스템 설계 도구인지 깨달았습니다. 특히 `GameplayTag`를 통해 캐릭터의 모든 상태(예: `State.Debuff.Suppressed`)를 중앙에서 관리하고, `GameplayEvent`를 통해 시스템 간의 통신을 표준화함으로써, 복잡한 멀티플레이어 환경에서의 상호작용을 매우 안정적이고 예측 가능하게 만들 수 있었습니다. GAS는 단순한 스킬 시스템을 넘어, 게임 전체의 상태와 로직을 아우르는 견고한 프레임워크였습니다.

## 3. 잘한 점 (What Went Well)

*   **스킬 타입 표준화**: 모든 스킬의 활성화 흐름을 `Instant`와 `WithPrepare` 두 가지 타입으로 표준화하여, 복잡성을 크게 낮추고 예측 가능한 코드를 만들 수 있었습니다.
*   **후속 입력 처리 통일**: `Waiting` 상태의 스킬이 후속 입력을 받는 방식을 `GameplayEvent`를 통해 일원화했습니다. 덕분에 개발자는 입력 처리의 복잡한 내부 로직을 신경 쓸 필요 없이, `OnLeftClickInput`과 같은 이벤트 핸들러만 구현하면 되어 생산성이 크게 향상되었습니다.
*   **1인칭/3인칭 프리뷰 분리**: 스킬 준비 시 손에 보이는 장착물(Preview)을 1인칭(로컬, 비복제)과 3인칭(서버, 복제)으로 분리하여, 사용자에게는 즉각적인 피드백을 제공하면서도 네트워크 효율을 최적화할 수 있었습니다.

## 4. 아쉬웠던 점 및 개선 방향 (What Could Be Improved)

### GameplayCue 미활용

*   **현황**: 이펙트(VFX/SFX)나 상태 변화(UI 피드백)를 알리기 위해 `Multicast RPC`를 직접 호출하는 방식에 크게 의존했습니다.
*   **개선 방향**: `GameplayCue` 시스템을 도입하여, `GameplayCue_Execute`와 같은 태그를 보내는 것만으로 이펙트를 트리거하도록 변경할 수 있습니다. 이를 통해 어빌리티 코드와 이펙트/사운드 에셋 간의 의존성을 제거하고, 디자이너가 코드 수정 없이 이펙트를 교체할 수 있는 유연한 구조를 만들 수 있습니다. ([상세 리팩토링 예시](./4.1_Refactoring_Example-GameplayCue.md))

### GameplayTask의 제한적 활용

*   **현황**: 제트의 \'상승기류\' 스킬에서, 캐릭터의 중력 값을 일시적으로 변경했다가 0.3초 후에 복원하기 위해 C++의 `FTimerHandle`을 직접 사용했습니다.
*   **개선 방향**: 이 로직은 GAS가 제공하는 `AbilityTask_WaitDelay`로 대체하는 것이 더 바람직합니다. 어빌리티 내에서 태스크를 생성하고, 태스크의 `OnFinish` 델리게이트에 중력을 복원하는 로직을 바인딩하는 방식입니다. 이 경우, 어빌리티의 흐름이 하나의 함수 내에서 선언적으로 표현되어 가독성이 높아지며, 어빌리티가 종료될 때 태스크가 자동으로 함께 정리되므로 타이머 관리에 신경 쓸 필요가 없어집니다.

### GameplayEvent를 통한 소통 부족

*   **현황**: 어빌리티가 `Waiting` 상태에 진입하여 후속 입력 UI를 표시해야 할 때, `OnWaitAbility`라는 C++ 델리게이트를 직접 브로드캐스트합니다. `ABaseAgent`는 이 델리게이트에 자신의 HUD 업데이트 함수를 바인딩하여 UI를 표시합니다. 이 방식은 잘 동작하지만, `UBaseGameplayAbility`가 자신을 사용하는 `ABaseAgent`의 존재와 특정 함수를 암묵적으로 알게 되는 약한 결합을 만듭니다.
*   **개선 방향**: 이 직접적인 델리게이트 호출을 `GameplayEvent` 전송으로 대체할 수 있습니다. 어빌리티는 `Waiting` 상태가 되면 `Ability.UI.ShowFollowUp`과 같은 의미있는 태그를 담아 `SendGameplayEventToActor`를 호출하여 자신의 상태 변화를 외부에 알리기만 하면 됩니다. `ABaseAgent`는 특정 어빌리티의 델리게이트가 아닌, 이 범용적인 `GameplayEvent`를 수신하여 UI를 업데이트하도록 변경합니다. 이를 통해 어빌리티는 외부 시스템에 대해 전혀 알 필요가 없게 되어, 시스템 간의 결합도가 더욱 낮아지고 재사용성이 극대화됩니다.

## 5. 관련 문서

*   **[어빌리티 프레임워크](./1.2_Project-GAS-Architecture.md)**
*   **[스킬 대량 구현](./1.4_Scalable-Skill-Production.md)**
*   **[Flash 시스템](./2.1_Flash-System.md)**
*   **[GameplayCue 리팩토링 예시](./4.1_Refactoring_Example-GameplayCue.md)**
